/*
 *
 *  * Copyright (c) 2025 Benjamin Sautner
 *  *
 *  * Licensed under the Apache License, Version 2.0 (the "License");
 *  * you may not use this file except in compliance with the License.
 *  * You may obtain a copy of the License at
 *  *
 *  *     http://www.apache.org/licenses/LICENSE-2.0
 *  *
 *  * Unless required by applicable law or agreed to in writing, software
 *  * distributed under the License is distributed on an "AS IS" BASIS,
 *  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  * See the License for the specific language governing permissions and
 *  * limitations under the License.
 *
 *
 */

package io.github.bsautner.ksp.routing

import com.google.devtools.ksp.processing.SymbolProcessorEnvironment
import com.google.devtools.ksp.symbol.KSClassDeclaration
import com.squareup.kotlinpoet.CodeBlock
import com.squareup.kotlinpoet.FileSpec
import com.squareup.kotlinpoet.FunSpec
import io.github.bsautner.kobold.KoboldStatic
import io.github.bsautner.ksp.processor.BaseProcessor
import io.github.bsautner.ksp.processor.KoboldProcessor
import io.github.bsautner.ksp.processor.TargetPlatform
import io.github.bsautner.ksp.util.ImportManager
import io.ktor.resources.Resource
import io.ktor.server.application.Application
import java.util.Date

/**
 * TODO - add sorting and organize the generated routes.
 * add kdocs
 * fail on response and request objects not being Serializable
 */
class AutoRouter(val env: SymbolProcessorEnvironment) : BaseProcessor(env) {

	fun create(callback : (String) -> Unit) {

		val project = env.options["project"] ?: "Na"
		val routerName = "${project.first().uppercase()}${project.removeRange(0, 1)}$TARGET_ROUTER_NAME"
		val classPackage = KoboldProcessor::class.qualifiedName?.substringBeforeLast(".")

		val specBuilder = FileSpec.Companion.builder(classPackage!!, routerName)
		specBuilder
			.tag(TargetPlatform::class, TargetPlatform.jvmMain)
		    .addFileComment("${Date()}\n")
			.addFileComment("Auto Generated By Kobol https://github.com/bsautner/kobold\n")

		addStandardRouterImports()
		specBuilder.addFunction(
			FunSpec.Companion
				.builder("$project$TARGET_ROUTER_NAME")
				.receiver(Application::class)
				.addCode(createRoutes())
				.build()
		)
		ImportManager.addRouterImportBlock(specBuilder)
		val specFile = specBuilder.build()

		writeToFile(specFile, callback)


	}

 
	private fun addStandardRouterImports() {
		ImportManager.apply {
			this.addRouterImport("io.ktor.server.routing", "routing")
			this.addRouterImport("io.ktor.server.resources", "get", "post", "delete", "put")
			this.addRouterImport("io.ktor.util.reflect", "TypeInfo")
			this.addRouterImport("io.ktor.server.html", "respondHtml")
			this.addRouterImport("kotlinx.html", "html", "body", "div")
			this.addRouterImport("io.github.bsautner.kobold", "getPostBodyClass", "getPostResponseBodyClass")
			this.addRouterImport("io.ktor.server.request", "receive")
			this.addRouterImport("io.ktor.server.request", "receiveMultipart", "receiveParameters")
			this.addRouterImport("io.ktor.http", "HttpStatusCode")
			this.addRouterImport("kotlin.reflect", "safeCast")
			this.addRouterImport("io.ktor.server.http.content", "staticResources", "staticFiles")
			this.addRouterImport("java.io", "File")
		}


	}


	private fun createRoutes(): CodeBlock {
		val builder = CodeBlock.Companion.builder()
		builder
			.beginControlFlow("routing")
			.add(buildRouteCodeBlock())
			.endControlFlow()

		return builder.build()
	}

	private fun buildRouteCodeBlock(): CodeBlock {
		val builder = CodeBlock.Companion.builder()
		Routes.map.values.forEach {
			builder.add(it)
		}
		return builder.build()
	}

	private fun createWebRoute(declaration: KSClassDeclaration): CodeBlock {
		val block = CodeBlock.Companion.builder()
		return block
			.beginControlFlow("get<${declaration.simpleName.asString()}>")
    	     .beginControlFlow("call.respondHtml")
		.beginControlFlow("body")
		.addStatement("it.render.invoke(this)")
		.endControlFlow().endControlFlow()
		.endControlFlow()
			.build()
	}

	fun createGetRouter(declaration: KSClassDeclaration): CodeBlock {
		val block = CodeBlock.Companion.builder()
		block.beginControlFlow("get<${declaration.simpleName.asString()}>")

		val metaData = classHelper.getTypeParameters(declaration)
		log(metaData)
//
//		metaData.first().let {
//
//			block.addStatement(" call.respond(it.render.invoke() as $it, typeInfo = TypeInfo($it::class))")
//
//		}

		block.endControlFlow()

		return block.build()
	}

	companion object {

		const val TARGET_ROUTER_NAME = "AutoRouter"

		const val PATH = "path"
	}

}